/**
 * @fileoverview Firestore Security Rules for the Munerator application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data while allowing public read access to shared game data.
 * Administrative access is restricted to super admins.
 *
 * Data Structure:
 * - User-specific data (profiles, gladiators, wallets, games, tickets) is nested under `/users/{userId}`.
 * - Globally accessible game types are stored in `/gameTypes/{gameTypeId}`.
 * - Moderator actions are stored in `/moderatorActions/{moderatorActionId}` and are restricted to moderators.
 * - Free games are stored in `/freegames/{gameId}` and are publicly writable by anonymous users.
 * - Sponsors (Munerators) are stored in `/sponsors/{sponsorId}`, with access restricted to the sponsor themselves.
 * - Operators (Admins) are stored in `/operators/{operatorId}`, with access restricted to super admins.
 *
 * Key Security Decisions:
 * - User listing is generally disallowed to protect privacy.
 * - Public read access is granted to the `gameTypes` collection.
 * - Free games and their tickets are publicly writable to support anonymous play.
 * - The default security posture for ambiguous relationships is strict owner-only access.
 *
 * Denormalization for Authorization:
 * No explicit denormalization is performed in this ruleset. All authorization decisions are based on path-based ownership or super admin status.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Authentication required for most operations.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces path-based ownership.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user's UID matches the resource's owner ID and the document exists.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Combines ownership and existence checks for safe updates/deletes.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

        /**
         * @description Checks if the authenticated user is a super admin.
         * @path N/A
         * @allow N/A
         * @deny N/A
         */
        function isSuperAdmin() {
            return get(/databases/$(database)/documents/operators/$(request.auth.uid)).data.SuperAdmin == 'Yes';
        }


    /**
     * @description Rules for the /sponsors/{sponsorId} collection.
     * @path /sponsors/{sponsorId}
     * @allow (get, list) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 reading their own sponsor document.
     * @allow (create, update, delete) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 writing to their own sponsor document.
     * @deny (get, list) User otherUser attempting to read sponsor data.
     * @deny (create, update, delete) User otherUser attempting to write to sponsor data.
     * @principle Enforces document ownership for sponsors.
     */
    match /sponsors/{sponsorId} {
      // Only allow access if the user is signed in and the sponsorId matches their UID.
      allow get: if isSignedIn() && isOwner(sponsorId);
      allow list: if false; // Prevent listing all sponsors

      // Allow create, update, delete only if the user is the owner
      allow create: if isSignedIn() && isOwner(sponsorId) && request.resource.data.id == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(sponsorId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(sponsorId);

      /**
       * @description Rules for the /sponsors/{sponsorId}/games/{gameId} subcollection.
       * @path /sponsors/{sponsorId}/games/{gameId}
       * @allow (get, list) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 reading their own game document.
       * @allow (create, update, delete) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 writing to their own game document.
       * @deny (get, list) User otherUser attempting to read game data.
       * @deny (create, update, delete) User otherUser attempting to write to game data.
       * @principle Enforces document ownership for games within a sponsor's collection.
       */
      match /games/{gameId} {
        // Only allow access if the user is signed in and the sponsorId matches their UID.
        allow get: if isSignedIn() && isOwner(sponsorId);
        allow list: if isSignedIn() && isOwner(sponsorId);

        // Allow create, update, delete only if the user is the owner
        allow create: if isSignedIn() && isOwner(sponsorId);
        allow update: if isSignedIn() && isOwner(sponsorId) && resource != null;
        allow delete: if isSignedIn() && isOwner(sponsorId) && resource != null;
      }
    }

    /**
     * @description Rules for the /users/{userId}/userProfiles/{userProfileId} collection.
     * @path /users/{userId}/userProfiles/{userProfileId}
     * @allow (get, list) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 reading their own profile.
     * @allow (create, update, delete) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 writing to their own profile.
     * @deny (get, list) User otherUser attempting to read user profile data.
     * @deny (create, update, delete) User otherUser attempting to write to user profile data.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId}/userProfiles/{userProfileId} {
      // Only allow access if the user is signed in and the userId matches their UID.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isOwner(userId);

      // Allow create, update, delete only if the user is the owner and the IDs match.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId && userProfileId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id && userProfileId == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId) && userProfileId == userId;
    }

    /**
     * @description Rules for the /users/{userId}/arenaGladiators/{arenaGladiatorId} collection.
     * @path /users/{userId}/arenaGladiators/{arenaGladiatorId}
     * @allow (get, list) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 reading their own gladiator.
     * @allow (create, update, delete) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 writing to their own gladiator.
     * @deny (get, list) User otherUser attempting to read arena gladiator data.
     * @deny (create, update, delete) User otherUser attempting to write to arena gladiator data.
     * @principle Enforces document ownership for arena gladiators.
     */
    match /users/{userId}/arenaGladiators/{arenaGladiatorId} {
      // Only allow access if the user is signed in and the userId matches their UID.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isOwner(userId);

      // Allow create, update, delete only if the user is the owner.
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/wallets/{walletId} collection.
     * @path /users/{userId}/wallets/{walletId}
     * @allow (get, list) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 reading their own wallet.
     * @allow (create, update, delete) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 writing to their own wallet.
     * @deny (get, list) User otherUser attempting to read wallet data.
     * @deny (create, update, delete) User otherUser attempting to write to wallet data.
     * @principle Enforces document ownership for wallets.
     */
    match /users/{userId}/wallets/{walletId} {
      // Only allow access if the user is signed in and the userId matches their UID.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isOwner(userId);

      // Allow create, update, delete only if the user is the owner.
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/freePlayGames/{freePlayGameId} collection.
     * @path /users/{userId}/freePlayGames/{freePlayGameId}
     * @allow (get, list) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 reading their own free play game.
     * @allow (create, update, delete) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 writing to their own free play game.
     * @deny (get, list) User otherUser attempting to read free play game data.
     * @deny (create, update, delete) User otherUser attempting to write to free play game data.
     * @principle Enforces document ownership for free play games.
     */
    match /users/{userId}/freePlayGames/{freePlayGameId} {
      // Only allow access if the user is signed in and the userId matches their UID.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isOwner(userId);

      // Allow create, update, delete only if the user is the owner.
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/arenaGladiators/{arenaGladiatorId}/gameTickets/{gameTicketId} collection.
     * @path /users/{userId}/arenaGladiators/{arenaGladiatorId}/gameTickets/{gameTicketId}
     * @allow (get, list) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 reading their own game ticket.
     * @allow (create, update, delete) User zC7Hg1lsX9ekVc0tVsGwb0AVolo2 writing to their own game ticket.
     * @deny (get, list) User otherUser attempting to read game ticket data.
     * @deny (create, update, delete) User otherUser attempting to write to game ticket data.
     * @principle Enforces document ownership for game tickets.
     */
    match /users/{userId}/arenaGladiators/{arenaGladiatorId}/gameTickets/{gameTicketId} {
      // Only allow access if the user is signed in and the userId matches their UID.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isOwner(userId);

      // Allow create, update, delete only if the user is the owner.
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Rules for the /gameTypes/{gameTypeId} collection.
     * @path /gameTypes/{gameTypeId}
     * @allow (get, list) Public read access for all game types.
     * @deny (create, update, delete) No write access allowed for anyone.
     * @principle Public read, no write access.
     */
    match /gameTypes/{gameTypeId} {
      // Allow anyone to read game types.
      allow get, list: if true;

      // No one can create, update, or delete game types.
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /moderatorActions/{moderatorActionId} collection.
     * @path /moderatorActions/{moderatorActionId}
     * @allow (get, list) Moderators and administrators can read moderator actions.
     * @allow (create, update, delete) Only super admins can write to moderator actions.
     * @deny (get, list) Regular users cannot read moderator actions.
     * @deny (create, update, delete) Regular users cannot write to moderator actions.
     * @principle Restricts access to moderator actions to authorized personnel.
     */
    match /moderatorActions/{moderatorActionId} {
      // Only allow access if the user is a super admin.
      allow get, list: if isSignedIn() && isSuperAdmin();

      // Only super admins can create, update, or delete moderator actions.
      allow create, update, delete: if isSignedIn() && isSuperAdmin();
    }

    /**
     * @description Rules for the /freegames/{gameId} collection.
     * @path /freegames/{gameId}
     * @allow (get, list) Public read access for all free games.
     * @allow (create, update, delete) Public write access for all free games.
     * @principle Public read and write access for free games.
     */
    match /freegames/{gameId} {
      // Allow anyone to read free games.
      allow get, list: if true;

      // Allow anyone to create, update, or delete free games.
      allow create, update, delete: if true;

      /**
       * @description Rules for the /freegames/{gameId}/tickets/{ticketId} subcollection.
       * @path /freegames/{gameId}/tickets/{ticketId}
       * @allow (get, list) Public read access for all free game tickets.
       * @allow (create, update, delete) Public write access for all free game tickets.
       * @principle Public read and write access for free game tickets.
       */
      match /tickets/{ticketId} {
        // Allow anyone to read free game tickets.
        allow get, list: if true;

        // Allow anyone to create, update, or delete free game tickets.
        allow create, update, delete: if true;
      }
    }

    /**
     * @description Rules for the /operators/{operatorId} collection.
     * @path /operators/{operatorId}
     * @allow (get, list) Only Super Admins can read Operators.
     * @allow (create, update, delete) Only Super Admins can create, update, or delete Operators.
     * @deny (get, list) Non-Super Admins cannot read Operators.
     * @deny (create, update, delete) Non-Super Admins cannot create, update, or delete Operators.
     */
    match /operators/{operatorId} {
      // Only allow access if the user is a super admin.
      allow get, list: if isSignedIn() && isSuperAdmin();

      // Only super admins can create, update, or delete operators.
      allow create: if isSignedIn() && isSuperAdmin() && request.resource.data.UID == operatorId;
      allow update: if isSignedIn() && isSuperAdmin() && resource != null && request.resource.data.UID == operatorId;
      allow delete: if isSignedIn() && isSuperAdmin() && resource != null;
    }
  }
}